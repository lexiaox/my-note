### 📂 Lab-False-Sharing-Test.md 实验记录
---
tags: [Lab, Architecture, Cache-Optimization]
target: 验证 Cache Line 伪共享带来的性能损耗
platform: Lenovo Legion Y7000P (Intel i7, 64-byte Cache Line)
---

# 🧪 实验：伪共享 (False Sharing) 压力测试与消除

## 1. 实验核心逻辑
对比两个线程同时写入物理内存相邻变量（BadStruct）与隔离变量（GoodStruct）的耗时差异。

### 关键变量声明
```c
// 强制 CPU 读写内存，防止编译器将其优化至寄存器
struct BadStruct {
    volatile long long a;
    volatile long long b;
} bad_data;

struct GoodStruct {
    volatile long long a;
    char padding[64]; // 显式隔离，跨越一个 Cache Line
    volatile long long b;
} good_data;
````

## 2. 实验数据记录 (实测数据对比)

测试环境：`OMP_NUM_THREADS=2`, 迭代次数 $10^8$ 次。


| **优化等级**      | **结构体类型**  | **耗时 (秒)** | **性能差距 (倍率)** | **结论**              |
| ------------- | ---------- | ---------- | ------------- | ------------------- |
| **-O0** (无优化) | 伪共享 (Bad)  | 0.842      | 1.0x          | 基准                  |
| **-O0** (无优化) | 优化版 (Good) | 0.215      | **3.9x**      | 即使无优化，消除冲突也极快       |
| **-O2** (中度)  | 伪共享 (Bad)  | 0.205      | 1.0x          | 编译器尝试通过流水线掩盖延迟      |
| **-O2** (中度)  | 优化版 (Good) | 0.026      | **7.8x**      | **性能鸿沟显现**          |
| **-O3** (激进)  | 伪共享 (Bad)  | 0.199      | 1.0x          | -                   |
| **-O3** (激进)  | 优化版 (Good) | 0.000007   | **~28000x**   | **失效记录**: 循环被完全优化消除 |
|               |            |            |               |                     |

## 3. 结果分析与复盘 🧠

### 3.1 为什么耗时差距如此巨大？

- **硬件原因**: 核心 0 修改 `a` 导致核心 1 缓存行变为 `Invalid`。核心 1 修改 `b` 必须等待总线同步并重新加载。
    
- **MESI 协议成本**: 大量的跨核通信（Snoop Traffic）占满了内部总线。
    

### 3.2 编译器优化带来的干扰

> [!WARNING] 实验笔记
> 
> 1. 在不使用 `volatile` 时，`-O3` 下两个版本的耗时几乎相同，因为变量被锁死在 **寄存器** 中，不产生内存流量。
>     
> 2. **IT 民工教训**: 性能测试必须确保测试对象确实产生了内存访问，否则数据是“虚假”的。
>     

## 4. 诊断工具证据 (perf c2c)

虽然环境安装曲折，但理论预期如下：

- **BadStruct**: `HITM` (Hit Modified) 指标极高，指示严重的核心间缓存争用。
    
- **GoodStruct**: `HITM` 接近于 0。
    

---

## 5. 原始 Markdown 源码备份

### 结论

在多线程高频写入共享数据结构时，必须考虑成员变量在物理内存中的布局。通过 `padding` 或 `alignas(64)` 可以获得量级上的性能提升。


---

### 🎨 针对你的 Obsidian 优化建议

1.  **数据可视化**: 你可以安装 `Obsidian Charts` 插件。用这个表格的数据画一个柱状图，直观展示“伪共享版”和“对齐版”在不同优化等级下的耗时曲线。
2.  **代码复用**: 既然你常用 **Termux**，可以把这个实验的 `gcc` 编译和运行指令写成一个 `.sh` 脚本，并将脚本内容附在笔记末尾。
3.  **双向链接**: 在“MESI 协议成本”处，记得链接到 `[[03-Hardware-Details]]`。

---

### 总结：

到现在，你的 Obsidian 库里已经躺着一份非常有深度的高性能计算笔记了：
- **01-03**: 系统的理论框架。
- **Lab-Pi**: 算法层面的并行验证。
- **Lab-False-Sharing**: 硬件层面的调优实战。

这不仅是兰州大学课程的总结，更是你作为 IT 专业人士的底层技术储备。

**恭喜你，兰大并行计算的硬核内容我们已经全部“通关”了！** 下次如果你有关于 **网络安全（逆向/PWN）** 或者 **Linux 内核** 方面的硬核需求，随时找我探讨。
```