---
创建时间: 2025-12-29 14:37
tags:
  - 计算机系统
status: 📝 编写中
---
“向量化替换”这个过程，本质上就是把代码中**“单兵作战”**的逻辑，替换成**“集团军作战”**的逻辑。

结合你的报告内容 11，这个过程并不是魔法，而是需要程序员手动（或通过编译器自动）完成的三个核心步骤的转换。我们可以用一个具体的 $C[i] = A[i] + B[i]$ 的例子，配合你的 GEMM 场景来拆解这个过程：

### 第一步：数据容器的替换（从标量到向量）

这是最基础的物理层面的替换。

- 替换前 (Scalar)：
    
    你使用的是标准的 float 变量。它在 CPU 内部对应的是 XMM 寄存器的低 32 位（或者老式的 x87 栈）。它像一个小杯子，只能装 1 个数字。
    
- 替换后 (Vector)：
    
    你使用的是 __m256 类型变量。它对应 CPU 内部的 YMM 寄存器（AVX2 专用）。它像一个大托盘，必须一次性装满 8 个 单精度浮点数 2。
    

### 第二步：指令操作的替换（从串行到并行）

这是计算逻辑的替换，也是性能提升的来源。

- 替换前 (SISD)：
    
    编译器生成的是 vaddss (Add Scalar Single) 指令。
    
    - CPU 逻辑：取出 A 的 1 个数，取出 B 的 1 个数，加起来，放回去。
        
- 替换后 (SIMD)：
    
    你显式调用了 _mm256_add_ps，编译器生成的是 vaddps (Add Packed Single) 指令。
    
    - CPU 逻辑：**同时**打通 8 条计算通道（Lanes）。
        
    - Lane 0 计算 `A[0]+B[0]`，Lane 1 计算 `A[1]+B[1]` ... 直到 Lane 7。这一切发生在同一个时钟周期内。
        

### 第三步：循环控制的替换（步长的改变）

这是最容易被忽视但至关重要的一步。

- 替换前：
    
    for (int i = 0; i < N; i++)
    
    每次循环处理 1 个元素，所以下一次处理的是 i+1。
    
- 替换后：
    
    for (int i = 0; i < N; i += 8)
    
    既然你一次处理了 8 个元素（0~7），那么下一次进入循环时，必须跳过这 8 个，直接从 i+8 开始处理。
    

---

### 综合演示：一个完整的“替换”手术

让我们看看在你的矩阵乘法（$C \leftarrow C + A \times B$）微内核中，这个手术是怎么做的：

#### 1. 手术前（朴素 C 代码）

C

```
// 假设我们要计算第 k 行的乘加
for (int j = 0; j < N; j++) {
    // 动作：读1个A，读1个B，乘起来，加到C上
    C[j] += A_val * B[j]; 
}
```

#### 2. 手术中（向量化替换过程）

1. 准备广播 (Broadcast)：
    
    因为 A_val 对于这一行来说是固定的常数，我们需要把它从“1个标量”变成“8个一样的向量”。
    
    - 操作：`_mm256_broadcast_ss`
        
    - 效果：`[A, A, A, A, A, A, A, A]`
        
2. 批量加载 (Load)：
    
    把 B[j] 的读取换成向量加载。
    
    - 操作：`_mm256_load_ps(&B[j])`
        
    - 效果：一次抓取 `B[j]...B[j+7]`。
        
3. 融合乘加 (FMA)：
    
    把 += * 替换为 AVX2 专用的 FMA 指令 3。
    
    - 操作：`_mm256_fmadd_ps(vA, vB, vC)`
        
    - 含义：同时计算 8 组 `C = C + A * B`。
        

#### 3. 手术后（AVX2 代码）

C

```
// 1. 把 A_val 复制 8 份填满寄存器
__m256 vA = _mm256_set1_ps(A_val); 

// 2. 循环步长改为 8
for (int j = 0; j < N; j += 8) {
    // 3. 向量加载 C 和 B
    __m256 vC = _mm256_load_ps(&C[j]);
    __m256 vB = _mm256_load_ps(&B[j]);
    
    // 4. 向量化计算 (FMA)
    vC = _mm256_fmadd_ps(vA, vB, vC);
    
    // 5. 向量回写
    _mm256_store_ps(&C[j], vC);
}
```

### 总结

“向量化替换”就是程序员充当翻译官，把高级语言里**“对单个数据的描述”**，强行翻译成硬件能听懂的**“对成组数据的指令”**。在你的报告中，这个过程让计算密度提升了 8 倍 4，但如果像你上一条问的那样“简单替换”（不考虑数据依赖和流水线），就会遇到性能瓶颈。