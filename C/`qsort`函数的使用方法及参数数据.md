---
创建时间: 2025-12-25 17:34
tags:
  - C
  - qsort
status: 📝 编写中
---

`qsort` 是 C 语言标准库 `<stdlib.h>` 中提供的**快速排序 (Quick Sort)** 函数。

因为它是一个**通用**函数（Generic Function），设计者不知道你要排的是整数、浮点数、还是巨大的结构体，所以它的参数设计得非常抽象。

你可以把 `qsort` 想象成一个**“只懂排队逻辑，但不懂排队对象”的盲人指挥官**。你需要通过这 4 个参数把所有细节告诉它。

### 函数原型



```C
void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
```

我们结合你项目中的代码 `qsort(idx1, n, sizeof(int), cmp_t1);` 来逐个拆解：

---

### 1. `void *base` —— 队伍站在哪？

- **含义**：这是你要排序的**数组的起始地址**。
    
- **为什么是 `void *`？**：因为 C 语言没有泛型（Templates），为了能接收 `int[]`、`double[]` 甚至 `struct[]`，只能用万能指针 `void *`。
    


### 2. `size_t nmemb` —— 队伍有多少人？

- **含义**：数组里一共有多少个元素。
    
- **你的代码**：`n` (即 11,099)
    
    - 告诉指挥官：“你要处理 11,099 个对象，别越界了。”
        

### 3. `size_t size` —— 每个人有多宽？

- **含义**：数组中**单个元素**占用多少字节内存。
    
- **核心作用**：指挥官只知道首地址，不知道下一个元素在哪。有了这个 `size`，它就知道：
    
    - 第 0 个在 `base`。
        
    - 第 1 个在 `base + size`。
        
    - 第 2 个在 `base + 2*size`。
        
- **你的代码**：`sizeof(int)`
    
    - 这一点非常关键！因为你排的是 `idx1`（整数数组），所以每个元素宽 4 字节（int 的大小）。
        
    - **千万别写成** `sizeof(GeneData)`，那样指针步长就错了，程序会直接崩溃（Segfault）。
        

### 4. `int (*compar)(...)` —— 谁应该排前面？（裁判）

- **含义**：这是一个**函数指针**。你需要自己写一个比较函数传进去。
    
- **为什么需要它？**：`qsort` 不知道怎么比较两个元素。比如结构体 A 和 结构体 B 谁大？它不知道。它只负责**调换位置**，比较大小的逻辑外包给你。

    

---
