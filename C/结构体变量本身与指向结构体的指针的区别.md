这个问题总结得很到位。是的，你的理解是完全正确的。

在 C 语言中，访问结构体成员的规则严格依赖于你操作的是**结构体变量本身**还是**指向结构体的指针（地址）**。

### 总结两种访问方式

| **运算符**          | **作用对象**  | **含义**              | **示例**                | **场景**                |
| ---------------- | --------- | ------------------- | --------------------- | --------------------- |
| **`.` (点运算符)**   | **结构体变量** | 直接访问结构体变量的成员。       | `Z za; za.d = 10;`    | 当你拥有结构体实例本身（不是它的地址）时。 |
| **`->` (箭头运算符)** | **结构体指针** | 通过指针间接访问它所指向的结构体成员。 | `Z * za; za->d = 10;` | 当你拥有指向结构体的指针（地址）时。    |

### `za->d` 的本质

`za->d` 实际上是以下操作的**简写（语法糖）**：

1. 先对指针 `za` 进行解引用操作 `*za`，得到指针指向的结构体变量。
    
2. 然后使用点运算符 `.` 访问该结构体变量的成员 `d`。
    

即：

$$\text{za}\to\text{d} \equiv (\text{*za}).\text{d}$$

在你之前写到的 `cmp` 函数中，`za` 是通过 `(Z *)a` 转换得到的**指针**，所以必须使用 `za->d`。如果你想用点运算符，理论上你必须先解引用：`(*za).d`，但这在实际编程中很少见，大家更倾向于使用简洁的箭头运算符 `->`。